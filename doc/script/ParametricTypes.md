## Parametric Types

### Overview

A parametric type is the type that takes parameters to introduce a family of types â€“ one for each possible combination of parameter values. For instance, an array is an parametric type with two parameters: element_type and length. An array of four integers is one of the array types in the family of the parametric array type, with a parameter value combination where element_type=int and length=4. There are many languages that support some version of parametric mechanism (or generic programming), but none supports true parametric polymorphism.

An Alt parametric type is a true type. It can be used as an abstract type for polymorphic variable declarations, wherein the type parameters may be left undetermined. A parametric type has its position in the type system's subtype hierarchy. This gives a whole new horizon of applications on generic programming to address many traditional unanswered questions in static parametric type systems, just to name a few:

 * Can we consider an array of integers a subtype of an array of numeric numbers because an integer is a subtype of numeric number?
 * Can we covariantly define the input interface in subtype?
 * Can we easily specify type dependency among input and output in an interface?
 * Can we override a parametric interface (make it virtual) in a subtype?

Alt parametric types will have positive answers for these.

### Parametric Type Declaration

Since a parametric type is a type, we do not need any keyward such as generic or template to distinguish between a type and a parametric type, simply introduce parameters in a parametric type in a pair of parentheses prefixed with #:

```altscript
class array #(type element_type: any; length: uint);
```

This declaration defines a new parametric type, a class `array`, with two parameters: a type parameter `element_type`, and a constant value parameter `length`. The parametric type `array` defines a family of containers hodling a given number of elements of the given type, where `length` is given the number, and `element_type` is the given element type. All types derived from `array` are subtypes of `array` - and this is not possible in other programming languages where parametric types are not true types and there is no base for the concept of subtype on parametric types.

A type parameter has the `type` specifier in the declareation:

```altscript
type element_type: any
```

What, one may ask, is the role of `: any` in the declareation? Well, that's the point of constrained type parameter: it specifies that the `element_type` can be any subtype of 'any', and in this case, it can be any type at all.

Consider another example:

```altscript
class Point #(type UnitT: numeric) { x: UnitT; y: UnitT; };
```

This defines a parametric type, a class `Point`, which has two member elements, `x` and `y`, both in a subtype of the `numeric` type.

### Parametric Type Refinement

A parametric type can be refined into subtypes by re-constraining or binding its parameters. A parametric type becomes a concrete type, that is, a type that can used to instantiate objects/values, when all its parameters are bound to a type or a constant value.

A type paramether can be re-constrained in a subtype by providing a subtype of the constraining type given in the base type:

```altscript
type numeric_array = array #(type element_type: numeric);
```

This defines a numeric array, a subtype of array, where the element type is re-constrained to any numeric type, where `numeric` is a subtype of `any`, a constraining type given in the base type `array`.

A type paramether can also be bound to a type in a subtype. In most cases, the given type for the binding is a concrete type, but can also be an abstract type.

```altscript
type integer_array = array #(type element_type = int);
```
or simply put,
```altscript
type integer_array = array #(int);
```

This defines an integer array, a subtype of numeric_array, where the element type is bound to the type `int`, which is a concrete type. This is a homogeneous array in which all elements are in the same integer type.  We can also bind a type parameter to an abstract type:

```altscript
type mixed_numeric_array = array #(type element_type = numeric);
```
or simply put,
```altscript
type mixed_numeric_array = array #(numeric);
```

This defines a mixed numeric array, a subtype of array, where the element type is bound to the abstract type `numeric`. This is a hetrougeneous array which may contain values of any type of numbers, as long as they are values in a subtype of `numeric`, or in other words, it can contains mixed values such as short integers, long integer, floats, and doubles.

### Parametric Subtype

Subtypes of a parametric type are generated by refining parameters. However, once a type parameter is bound, it cannot be re-bound in a subtype. Therefore, `integer_array` is a subtype of `numeric_array`, but not a subtype of `mixed_numeric_array` because the element type is already bound in `mixed_numeric_array`.

Consider:

```altscript
x: array #(int, 4);
z: array #(numeric) = x;                        // error, array #(int, 4) is not a subtype of array #(type element_type=numeric)
y: array #(type element_type: numeric) = x;     // okay, array #(int, 4) is a subtype of array #(type element_type: numeric)
```

Let's consider the case of assignment of `x` to `z`. `z` is declared as a mixed numerical array that is able to hold all kinds of numeric values. Apparently, `x` does not meet what is declared for `z`. If we make `z` to refer to the value in `x`, the assignment of `z[0]=4.0` is legal by what we declare for `z`, but will fail to comply with what we assume for `x`.

Now we consider the case of assignment of `x` to `y`. `y` is polymorphic variable declared to hold any numeric array in which the element type is determined by the actual array type assigned to `y`. When `x` is assigned to `y`, `y` gets the actual type of array #(int, 4). Therefore, `y` can only take an element value which is in the element type of the actual array type of `y`:

```altscript
func foo #(type T: array #(type element_type: numeric))(y: T; e: T.element_type)
{
    y[0] = e;                      // okay, because e is the element type of array value that y holds
}
int4:    int[4] = (1,2,3,4);       // int[4] is a syntax sugar for array#(int, 4)
double4: double[4] = (1,2,3,4);    // double[4] is a syntax sugar for array#(double, 4)
foo(int4, 4);                      // okay, 4 is the element type of int4
foo(double4, 4);                   // okay, 4 is converted to double value
foo(double4, "string");            // error, "string" cannot be converted to the element type of double4
```

On a side note for the expression `T.element_type`, parameters of a parametric type are member names declared in the type scope and they can be accessed through the parametric type name using the operator `.` (the scope name selector). This notation makes it easier to represent a deep type dependnecy among arguments and we will explains this point later.

More subtype examples:

 * Point#(type T: integral) is a subtype of Point;
 * Point#(int) is a subtype of Point;
 * Point#(int) is a subtype of Point#(type T: integral);
 * Point#(int) is not a subtype of Point#(integral);
 * #(type T: integral) (x: T; y: T) is a subtype of #(type T: numeric) (x: T; y: T);
 * #(type T=integral) (x: T; y: T) is a subtype of #(type T: integral) (x: T; y: T);
 * (int; int) is a subtype of #(type T: integral) (x: T; y: T);
 * (int; int) is not a subtype of #(type T=integral) (x: T; y: T);

### Parametric Type Inheritance

### Parametric Interface Type


An array is a container for elements of the given element type, you can only set the element to the value of its element_type. For instance:

```altscript
class test
{
    func ele_assign #(type T: array)(x: T; index: uint; ele: T.element_type)
    {
        if (index <= T.length)
        {
            x[index] = ele;          // okay
        }
    }
    x : string[4];
    z : array = x;                   // a polymophic reference to any array
    enter()
    {
        z[0] = "text";               // error: type mismatch
        if (z[0] => z0 is string)
        {
            z0 = "text";             // okay
        }
        ele_assign(x, 0, "xyz");     // okay
        ele_assign(x, 0, 2);         // error:  no matched IO interface is found to call ele_assign
    }
}
```

