## Parametric Types

### Overview

A parametric type is the type that takes parameters to introduce a family of types â€“ one for each possible combination of parameter values. For instance, an array is an parametric type with two parameters: element_type and length. An array of four integers is one of the array types in the family of the parametric array type, with a parameter value combination where element_type=int and length=4. There are many languages that support some version of parametric mechanism (or generic programming), but none supports true parametric polymorphism.

An Alt parametric type is a true type. It can be used as an abstract type for polymorphic variable declarations, wherein the type parameters may be left undetermined. A parametric type has its position in the type system's subtype hierarchy. This gives a whole new horizon of applications on generic programming to address many traditional unanswered questions in static parametric type systems, just to name a few:

 * Can we consider an array of integers a subtype of an array of numeric numbers because an integer is a subtype of numeric number?
 * Can we covariantly define the input interface in subtype?
 * Can we easily specify type dependency among input and output in an interface?
 * Can we override a parametric interface (make it virtual) in a subtype?

Alt parametric types will have positive answers for these.

### Parametric Type Declaration

Since a parametric type is a type, we do not need any keyward such as generic or template to distinguish between a type and a parametric type, simply introduce parameters in a parametric type in a pair of parentheses prefixed with #:

```altscript
class array #(type element_type: any; length: uint);
```

This declaration defines a new parametric type, a class `array`, with two parameters: a type parameter `element_type`, and a constant value parameter `length`. The parametric type `array` defines a family of containers hodling a given number of elements of the given type, where `length` is given the number, and `element_type` is the given element type. All types derived from `array` are subtypes of `array` - and this is not possible in other programming languages where parametric types are not true types and there is no base for the concept of subtype on parametric types.

A type parameter has the `type` specifier in the declareation:

```altscript
type element_type: any
```

What, one may ask, is the role of `: any` in the declareation? Well, that's the point of constrained type parameter: it specifies that the `element_type` can be any subtype of 'any', and in this case, it can be any type at all.

Consider another example:

```altscript
class Point #(type UnitT: numeric) { x: UnitT; y: UnitT; }
```

This defines a parametric type, a class `Point`, which has two member elements, `x` and `y`, both in a subtype of the `numeric` type.

### Parametric Type Refinement

A parametric type can be refined into subtypes by re-constraining or binding its parameters. A parametric type becomes a concrete type, that is, a type that can used to instantiate objects/values, when all its parameters are bound to a type or a constant value.

A type paramether can be re-constrained in a subtype by providing a subtype of the constraining type given in the base type:

```altscript
type numeric_array = array #(type element_type: numeric);
```

This defines a numeric array, a subtype of array, where the element type is re-constrained to any numeric type, where `numeric` is a subtype of `any`, a constraining type given in the base type `array`.

A type paramether can also be bound to a type in a subtype. In most cases, the given type for the binding is a concrete type, but can also be an abstract type.

```altscript
type integer_array = array #(type element_type = int);
```
or simply put,
```altscript
type integer_array = array #(int);
```

This defines an integer array, a subtype of numeric_array, where the element type is bound to the type `int`, which is a concrete type. This is a homogeneous array in which all elements are in the same integer type.  We can also bind a type parameter to an abstract type:

```altscript
type mixed_numeric_array = array #(type element_type = numeric);
```
or simply put,
```altscript
type mixed_numeric_array = array #(numeric);
```

This defines a mixed numeric array, a subtype of array, where the element type is bound to the abstract type `numeric`. This is a hetrougeneous array which may contain values of any type of numbers, as long as they are values in a subtype of `numeric`, or in other words, it can contains mixed values such as short integers, long integer, floats, and doubles.

### Parametric Subtype

Subtypes of a parametric type are generated by refining parameters covariantly. However, once a type parameter is bound, it becomes invariant and cannot be re-bound to form a subtype. Therefore, `integer_array` is a subtype of `numeric_array`, but not a subtype of `mixed_numeric_array` because the element type is already bound in `mixed_numeric_array`.

Consider:

```altscript
x: array #(int, 4);
z: array #(numeric) = x;                        // error, array #(int, 4) is not a subtype of array #(type element_type=numeric)
y: array #(type element_type: numeric) = x;     // okay, array #(int, 4) is a subtype of array #(type element_type: numeric)
```

Let's consider the case of assignment of `x` to `z`. `z` is declared as a mixed numerical array that is able to hold all kinds of numeric values. Apparently, `x` does not meet what is declared for `z`. If we make `z` to refer to the value in `x`, the assignment of `z[0]=4.0` is legal by what we declare for `z`, but will fail to comply with what we assume for `x`.

Now we consider the case of assignment of `x` to `y`. `y` is polymorphic variable declared to hold any numeric array in which the element type is determined by the actual array type assigned to `y`. When `x` is assigned to `y`, `y` gets the actual type of array #(int, 4). Therefore, `y` can only take an element value which is in the element type of the actual array type of `y`:

```altscript
func foo #(type T: array #(type element_type: numeric))(y: T; e: T.element_type)
{
    y[0] = e;                      // okay, because e is the element type of array value that y holds
}
int4:    int[4] = (1,2,3,4);       // int[4] is a syntax sugar for array#(int, 4)
double4: double[4] = (1,2,3,4);    // double[4] is a syntax sugar for array#(double, 4)
foo(int4, 4);                      // okay, 4 is the element type of int4
foo(double4, 4);                   // okay, 4 is converted to double value
foo(double4, "string");            // error, "string" cannot be converted to the element type of double4
```

On a side note for the expression `T.element_type`, parameters of a parametric type are member names declared in the type scope and they can be accessed through the parametric type name using the operator `.` (the scope name selector). This notation makes it easier to represent a deep type dependnecy among arguments and we will explains this point later.

More subtype examples:

 * Point#(type T: integral) is a subtype of Point;
 * Point#(int) is a subtype of Point;
 * Point#(int) is a subtype of Point#(type T: integral);
 * Point#(int) is not a subtype of Point#(integral);
 * #(type T: integral) (x: T; y: T) is a subtype of #(type T: numeric) (x: T; y: T);
 * #(type T=integral) (x: T; y: T) is a subtype of #(type T: integral) (x: T; y: T);
 * (int; int) is a subtype of #(type T: integral) (x: T; y: T);
 * (int; int) is not a subtype of #(type T=integral) (x: T; y: T);

### Parametric Type Inheritance

A parametric type can generate subtypes by refining parameters. However, a parametric type, as an abstract type, is often used as a base class (or super-class) to derive sub-classes in which more features than just parameter refinement are required. This is quite common when we need to add more member data and functions in a subtype. When a parametric class is used as a base class in inheritance, parameters of the parametric class can be bound to a type or a value to make the parametric class a concrete base type:

```altscript
class IntPoint is Point #(int) { }
```

This defines a derived class, `IntPoint`, with base `Point #(int)`, which is a subtype of Point.

If the derived class is a parametric class, the type parameter of its parametric base class can be bound to the type parameter of the derived class: 

```altscript
class IntegralPoint #(type UnitT: integral) is Point #(UnitT) { }
```

This defines a subtype of Point in which the x and y diementsions are measured by a subtype of integral. It is still an abstract type because the type of the integral is not concrete yet. Here, the sybtype relation is explicitly established by class inheritance: `IntegralPoint` is a subtype of `Point`, `IntPoint` is a subtype of `Point`, but `IntPoint` is not a subtype of `IntegralPoint` although by pure parameter refinement, Point #(int) is a subtype of Point #(type UnitT: integral):

```altscript
x: Point #(int);
y: Point #(type UnitT: integral);
y = x;   // okay, Point #(int) is a subtype of Point #(type UnitT: integral)
```

Because class inheritance can add more refinements and extentions than parameter refinements, the subtype relationship must follow the inheritance hierarchy. Only when we derive `IntPoint` from `IntegralPoint`:

```altscript
class IntPoint is IntegralPoint #(int) { }
```

can `IntPoint` be the subtype of `IntegralPoint`.

It is considered as a usage case when we use a parametric class for a base class to derive subclass. Therefore, all parameters of the parametric class must be bound in the base class, either to a type or a value, or to a parameter of the derived class. This resembles the case of a function call in which you must provide all actual parameters, although you can use formal parameter in the outer function that encloses the function call.

### Parametric Interface Type

The input and output interface of a function or the input interface of a constructor can be parameterized. Unlike generic or template functions in other programming languages, aa ALT function with parametric interface type is a true callable type that can be called and executed directly without a static instantiation. Example:

```altscript
func append_array_to_stream #(type ArrayT: array)(a: ArrayT; s: stream#(ArrayT.element_type))
{
    foreach (e: a) s.append(e);
}
```

The function `append_array_to_stream` append the contents of an array into a stream. The interface type is parameterized by an array type parameter, and the element type of the stream is specified to be the same type of the array type:

```altscript
str_array : string[4];
int_array : int[4];
str_stream : string...;
int_stream : int...;
append_array_to_stream(str_array, str_stream);   // okay
append_array_to_stream(int_array, int_stream);   // okay
append_array_to_stream(int_array, str_stream);   // error
```

Because a parametric function is a true callable type, its parametric interfaces is overridable in subclass:

```altscript
class test
{
    class base
    {
        virtual func fill #(type T: numeric)(v: T; a: array#(T))
        {
            foreach (e: a) e = v;
        }
    }
    object instance: base
    {
        func fill #(type T: numeric)(v: T; a: array#(T))
        {
            base::fill(v, a);
            a.sort();
        }
    }
    y : base;
    x : int[4];
    enter
    {
        y = instance;
        y.fill(4, x);
    }
}
```

In the above example, the singleton object, `instance`, override the member function `fill` defined in the its base class. When the function `fill` is called through `y`, a polymorphic reference of `base`, the actual member function `fill` called will be the onc defined in `instance`.

### Covariant subtyping with Parametric Type

By making type construction via composition, inheritance, and parameterization in covariance instead of invariance or contravariance, more meaningful programs can be accepted and well-typed. While programmers often find contravariance unintuitive, they also wonder why an array of cat cannot be intuitively considered as a subtype of an array of animal in a covariant way. See [Covariance and contravariance](https://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29) for the complication to make subtyping covariant in other programming languages.

Since we treat a parametric type a true type, subtypes can be created by refining the type parameter covariantly, thus we can have array subtypes covariantly going with its element type:

 * `array#(Cat)` is a subtype of `array#(type element_type: Felidae)`
 * `array#(type element_type: Felidae)`  is a subtype of `array#(type element_type: Carnivora)` 
 * ...

Being a subtype, it must hold all promise declared in its base type. The type `array#(type element_type: Felidae)` declared an array type that can only contain cats of a given cat family, and the given cat family in `array#(Cat)` is Cat. However, the covariant chain stops once the type parameter is bound. Therefore, `array#(Cat)` cannot be a subtype of  `array#(Felidae)` because the element type is bound to `Felidae` in `array#(Felidae)`, which is an array that must be able to contain any mixed types of cats such as domestic cats, tigers and lions, and `array#(Cat)` cannot hold this promise.




